name: Business Central CI/CD Pipeline

on:
  push:
    branches: [Production, Staging]

  pull_request:
    branches: [Production, Staging]

jobs:
  build:
    runs-on: windows-latest
    
    env:
      APP_NAME: Helan_Dala-Dala_
      APP_VERSION: '1.0.0.${{ github.run_number }}'
      BC_ADMIN_USER: ${{ secrets.BC_ADMIN_USER }}
      BC_ADMIN_PASSWORD: ${{ secrets.BC_ADMIN_PASSWORD }}
      BC_URL: ${{ secrets.BC_URL }}
      BC_TENANT: ${{ secrets.BC_TENANT }}
      
    strategy:
      max-parallel: 2
      matrix:
        bc-version: ['24.0']  # Business Central version
        al-app-version: ['24.0.0.0']  # AL App version

    steps:
    - uses: actions/checkout@v4
  
    # Add this step to install .NET SDK
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'  # You can adjust this version as needed
        
    - name: Create Required AL Compiler Directories
      shell: pwsh
      run: |
        # Path to compiler in repository
        $compilerFolder = Join-Path $env:GITHUB_WORKSPACE "AL-Compiler"
        $dllsPath = Join-Path $compilerFolder "dlls"
        
        # Create the main directories structure
        $requiredDirs = @(
          (Join-Path $dllsPath "OpenXML"),
          (Join-Path $dllsPath "Service"),
          (Join-Path $dllsPath "Mock Assemblies"),
          (Join-Path $dllsPath "shared")
        )
        
        foreach ($dir in $requiredDirs) {
          if (-not (Test-Path $dir)) {
            New-Item -Path $dir -ItemType Directory -Force
            Write-Host "Created directory: $dir"
          }
        }
        
        # Create compiler bin structure if needed
        $binPath = Join-Path $compilerFolder "compiler/extension/bin"
        if (-not (Test-Path $binPath)) {
          New-Item -Path $binPath -ItemType Directory -Force
          Write-Host "Created compiler bin directory: $binPath"
        }
        
        # Create compiler analyzers path if needed
        $analyzersPath = Join-Path $binPath "Analyzers"
        if (-not (Test-Path $analyzersPath)) {
          New-Item -Path $analyzersPath -ItemType Directory -Force
          Write-Host "Created analyzers directory: $analyzersPath"
        }
        
    - name: Set App Version
      shell: pwsh
      run: |
        $appJsonPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "app.json"
        $appJson = Get-Content $appJsonPath | ConvertFrom-Json
        $appJson.version = $env:APP_VERSION
        $appJson | ConvertTo-Json -Depth 100 | Set-Content $appJsonPath
      
    - name: Install BcContainerHelper
      shell: pwsh
      run: |
        # Install BcContainerHelper module
        Install-Module BcContainerHelper -Force
        Import-Module BcContainerHelper
        
        # Verify module is loaded and check available commands
        Write-Host "Checking if BcContainerHelper is loaded..."
        Get-Module BcContainerHelper
        
        # List available commands to find the correct compile function
        Write-Host "Available commands in BcContainerHelper:"
        Get-Command -Module BcContainerHelper *Compile* | Select-Object -ExpandProperty Name
  
        
    - name: Compile AL App with packaged compiler
      shell: pwsh
      run: |
        # Path to compiler in repository
        $compilerFolder = Join-Path $env:GITHUB_WORKSPACE "AL-Compiler"
        
        # Create/ensure .alpackages folder
        New-Item -Path ".alpackages" -ItemType Directory -Force
        
        # Import the BcContainerHelper module
        Import-Module BcContainerHelper -DisableNameChecking

        # Find available .NET Core runtime directories
        $dotnetCorePath = Get-ChildItem -Path "C:\Program Files\dotnet\shared\Microsoft.NETCore.App" | 
                          Sort-Object -Property Name -Descending | 
                          Select-Object -First 1 -ExpandProperty FullName
        Write-Host "Using .NET Core path: $dotnetCorePath"
        
        # Create array of assembly probing paths
        $probingPaths = @(
          (Join-Path $compilerFolder "dlls\OpenXML"),
          (Join-Path $compilerFolder "dlls\Service"),
          (Join-Path $compilerFolder "dlls\Mock Assemblies"),
          (Join-Path $compilerFolder "dlls\shared"),
          $dotnetCorePath,
          "C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App\$($dotnetCorePath.Split('\')[-1])",
          "C:\Windows\Microsoft.NET\Assembly"
        )

        # Join paths for the -assemblyProbingPaths parameter
        $assemblyProbingPathsStr = $probingPaths -join ','
        Write-Host "Assembly probing paths: $assemblyProbingPathsStr"


        # Compile the app using the packaged compiler
        try {
          Compile-AppWithBcCompilerFolder `
            -compilerFolder $compilerFolder `
            -appProjectFolder $env:GITHUB_WORKSPACE `
            -appOutputFolder $env:GITHUB_WORKSPACE `
            -appSymbolsFolder (Join-Path $env:GITHUB_WORKSPACE ".alpackages") `
            -EnableCodeCop:$false `
            -EnableAppSourceCop:$false `
            -EnablePerTenantExtensionCop:$false `
            -assemblyProbingPaths $assemblyProbingPathsStr `
            -EnableUICop:$false
        }
        catch {
          Write-Warning "Compilation error: $_"
          Write-Host "Error details: $($_.Exception.Message)"
          
          # Try with more minimal parameters if the first attempt fails
          Write-Host "Attempting simplified compilation..."
          Compile-AppWithBcCompilerFolder `
            -compilerFolder $compilerFolder `
            -appProjectFolder $env:GITHUB_WORKSPACE `
            -appOutputFolder $env:GITHUB_WORKSPACE `
            -appSymbolsFolder (Join-Path $env:GITHUB_WORKSPACE ".alpackages") `
            -assemblyProbingPaths $assemblyProbingPathsStr
        }
        
        # Verify the app was created
        $appFilePath = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter "*.app" | Select-Object -First 1 -ExpandProperty FullName
        if ($appFilePath) {
          Write-Host "Successfully compiled app to: $appFilePath"
        } else {
          Write-Error "Failed to compile app, output file not found"
          exit 1
        }

    - name: Upload App Package
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}
        path: |
          *.app
    
    # Only continue to Docker build if this is a push to production (not PR)
    - name: Set build outputs
      id: vars
      run: |
        echo "::set-output name=branch::$(echo ${GITHUB_REF#refs/heads/})"
        echo "::set-output name=sha_short::$(git rev-parse --short HEAD)"
        echo "::set-output name=docker_tag::$(date +'%Y%m%d')_$(git rev-parse --short HEAD)"
    
    - name: Create Business Central Container & Commit Image
      shell: pwsh
      run: |
        # 1) Grab the artifacts & build the container with your .app published
        $artifactUrl = Get-BcArtifactUrl `
          -version ${{ matrix.bc-version }} `
          -country 'w1' `
          -select 'Latest'
        Write-Host "Artifact URL: $artifactUrl"

        New-BcContainer `
          -artifactUrl $artifactUrl `
          -containerName bc-build-${{ github.run_number }} `
          -includeApps "$env:GITHUB_WORKSPACE\*.app" `
          -accept_eula

        # 2) Commit that container to a new image
        $imageTag = "daladala/bc-app:${{ github.run_number }}"
        docker commit bc-build-${{ github.run_number }} $imageTag
        Write-Host "Created image: $imageTag"

        # 3) Push (if you have DockerHub creds set up on this runner)
        docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }}
        docker push $imageTag

        # 4) Clean up
        Remove-BcContainer -containerName bc-build-${{ github.run_number }} -force

  # docker-build-push:
  #   needs: build
  #   runs-on: ubuntu-latest
    
  #   steps:
  #     - uses: actions/checkout@v4
      
  #     - name: Download App Package
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: app-package
  #         path: ./app-package
      
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v2
      
  #     - name: Login to DockerHub
  #       uses: docker/login-action@v2
  #       with:
  #         username: ${{ secrets.DOCKERHUB_USERNAME }}
  #         password: ${{ secrets.DOCKERHUB_TOKEN }}
      
  #     - name: Build and push Docker image
  #       uses: docker/build-push-action@v4
  #       with:
  #         context: .
  #         push: true
  #         tags: |
  #           ${{ secrets.DOCKERHUB_USERNAME }}/bc-app:latest
  #           ${{ secrets.DOCKERHUB_USERNAME }}/bc-app:${{ needs.build.outputs.docker_tag }}
  #         cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bc-app:buildcache
  #         cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bc-app:buildcache,mode=max

  # docker-build-push:
  #   needs: build
  #   runs-on: windows-latest

  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Download Compiled App Artifact
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: ${{ env.APP_NAME }}
  #         path: ./app

  #     - name: Install BcContainerHelper
  #       shell: pwsh
  #       run: |
  #         Install-Module BcContainerHelper -Force
  #         Import-Module BcContainerHelper

  #     - name: Create Business Central Image with App
  #       shell: pwsh
  #       run: |
  #         $artifactUrl = Get-BcArtifactUrl -version '24.0' -country 'w1' -select 'Latest'
  #         Write-Host "Using Artifact URL: $artifactUrl"

  #         New-BcImage `
  #           -artifactUrl $artifactUrl `
  #           -imageName "daladala/bc-app:${{ github.run_number }}" `
  #           -includeApp "./app/*.app" `
  #           -multitenant:$true `
  #           -genericImageName "mcr.microsoft.com/businesscentral:generic"

  #         Write-Host "Successfully created custom BC Docker image with your .app file."